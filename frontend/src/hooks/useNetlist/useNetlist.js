import { useMemo } from 'react';
import { v4 as uuidv4 } from 'uuid'
import lodash from 'lodash';

function isConnected(el, connection) {
  return el.id === connection.start || el.id === connection.end;
}

function splitPorts(schematic) {
  for (const component of schematic.components) {
    for (const port of component.ports) {
      // Grab all connections to the port
      const connections = schematic.connections.filter((connection) =>
        isConnected(port, connection),
      );

      // If the port had more than 1 connection, split it into a node
      if (connections.length > 1) {
        // Create a new node
        const newNode = { id: uuidv4() };
        schematic.nodes.push(newNode);

        // Connect the port to the new node
        schematic.connections.push({
          id: uuidv4(),
          start: port.id,
          end: newNode.id,
        });

        // Move old port's connections to the new node
        for (const connection of connections) {
          if (connection.start === port.id) connection.start = newNode.id;
          else connection.end = newNode.id;
        }
      }
    }
  }

  return schematic;
}

// TODO: Condense unnecessary nodes
function condenseNodes(schematic) {
  return schematic;
}

function generateVirtualNode(schematic, virtualCount = 0) {
  // Check if there are nodes that match the name
  for (const node of schematic.nodes) {
    const pattern = new RegExp(`_net${virtualCount}`);

    // If the name already exists, try another one
    if (pattern.test(node.label?.name))
      return generateVirtualNode(schematic, ++virtualCount);
  }

  // Return the successful Virtual Node
  return { id: uuidv4(), label: { name: `_net${virtualCount}` } };
}

function withVirtualNodes(schematic) {
  for (const connection of schematic.connections) {
    // Search for all components that share this connection
    const connectors = schematic.components.filter((component) =>
      component.ports.find((port) => isConnected(port, connection)),
    );

    // If the connection is shared between 2 components,
    // create a new virtual node between them.
    if (connectors.length === 2) {
      // Create virtual node
      const virtualNode = generateVirtualNode(schematic);
      schematic.nodes.push(virtualNode);

      // Create new connection
      schematic.connections.push({
        id: uuidv4(),
        start: virtualNode.id,
        end: connection.end,
      });

      // Update old connection
      connection.end = virtualNode.id;
    }
  }

  return schematic;
}

function generateNodesString(component, schematic) {
  let nodeStr = '';

  for (const port of component.ports) {
    // Search for the node connected to the port
    const conn = schematic.connections.find((conn) => isConnected(port, conn));
    const node = schematic.nodes.find((node) => isConnected(node, conn));

    // Convert it into string
    nodeStr += (node.label?.name ?? node.id) + ' ';
  }

  // Trim the last space and return
  return lodash.trimEnd(nodeStr);
}

function buildNetlist(schematic) {
  // TODO: Add more info to the header (author, date, ...)
  let netlist = '# Analysis netlist generated by U=RIsolve v1.0.0\n\n';

  // Normalize the schematic's data model
  splitPorts(schematic);
  condenseNodes(schematic);
  withVirtualNodes(schematic);

  // Add each component to the netlist
  for (const component of schematic.components) {
    const nodesStr = generateNodesString(component, schematic);
    netlist += `${component.type}:${component.label?.name} ${nodesStr}\n`;
  }

  return netlist;
}

export function useNetlist(schematic) {
  return useMemo(() => {
    // Clone the schematic to not change the circuit itself
    const sch = lodash.cloneDeep(schematic);

    // Build the netlist
    return buildNetlist(sch);
  }, [schematic]);
};
